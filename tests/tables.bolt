import print, protect, throw, Error from core
import prefix, expect from "test"

let const case = prefix("tables")

case("Unshaped table assignments", fn {
    let a: {}
    
    a["test"] = 10
    
    a[10] = "hello"
    
    a[true] = false
    
    a[null] = "weird, but allowed!"
    
    let key = { x: 10 }
    a[key] = key
})

case("Anonymous table shapes", fn {
    let x = {
        a: 10,
        b: "hello",
        c: true,
        d: null,
        e: [1]
    }

    expect(typeof(x.a) == number,         "Field 'a' has incorrect type deduction")
    expect(typeof(x.b) == string,         "Field 'b' has incorrect type deduction")
    expect(typeof(x.c) == bool,           "Field 'c' has incorrect type deduction")
    expect(typeof(x.d) == type(null),     "Field 'd' has incorrect type deduction")
    expect(typeof(x.e) == type([number]), "Field 'e' has incorrect type deduction")
})

case("Map types", fn {
    let c: { ..number: string } = {
        1: "one",
        2: "two"
    }
    
    c[3] = "three"

    expect(typeof(c[0]) == type(string?), "Map index produces incorrect type")
    expect(    c[1]?,                     "Map index produces null incorrectly")
    expect(not c[4]?,                     "Map index produces value incorrectly")
    expect(c[3]! == "three",              "Index produces incorrect result")
})

case("Enum maps", fn {
    type Direction = enum { Up Down Left Right }

    let dir_to_ascii: { ..Direction: string } = {
        Direction.Up: "^",
        Direction.Down: "v",
        Direction.Left: "<", 
        Direction.Right: ">", 
    }

    expect(dir_to_ascii[Direction.Up]!    == "^", "Subscript 0 working")
    expect(dir_to_ascii[Direction.Down]!  == "v", "Subscript 1 working")
    expect(dir_to_ascii[Direction.Left]!  == "<", "Subscript 2 working")
    expect(dir_to_ascii[Direction.Right]! == ">", "Subscript 3 working")
})

case("Non-identifier table literals", fn {
    let d = {
        1: true,
        "helo": 10,
        true: fn { return null },
        null: "erm.. okay"
    }
    
    expect(d[1]      == true,         "Number subscript")
    expect(d["helo"] == 10,           "String literal subscript")
    expect(d.helo    == 10,           "Dot syntax subscript")
    expect(d[true]() == null,         "Boolean subscript")
    expect(d[null]   == "erm.. okay", "Null subscript")
})