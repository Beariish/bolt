import * from core

type Vec2 = {
    x: number,
    y: number,
}

method Vec2.add(other: Vec2) {
    return { x: this.x + other.x, y: this.y + other.y } into Vec2!
}

let a = { x: 5, y: 5 } into Vec2!
let b = { x: 10, y: 10 } into Vec2!

let c = a.add(b)
let d = a.add

print(c.x, c.y)
print(d(a, b).x, d(a, b).y)

for outer in 15 {
    let start_time = time()
    
    for i in 100000 {
        let a = { x: 5, y: 5 } into Vec2!
        let b = { x: 10, y: 10 } into Vec2!   
        let c = a.add(b)
    }

    //gc()

    let end_time = time()
    
    let duration_ms = end_time - start_time
    print("100k vec2 iterations took", duration_ms / 1000, "ms")
}


for outer in 15 {
    let start_time = time()

    for i in 100000 {
        let ax = 5
        let ay = 5
        let bx = 10
        let b_y = 10   
        let cx = ax + bx
        let cy = ay + b_y
    }

    let end_time = time()
        
    let duration_ms = end_time - start_time
    print("100k num iterations took", duration_ms / 1000, "ms")
}

/*
fn takes_cb(cb: fn(number): bool) {
    print(cb(100))
}

takes_cb(fn(x: number) {
    return x > 50
})

type BinOp = fn(number, number): number

fn add(x: number, y: number) { return x + y }

fn does_binop_or_add(binop: any, x: number, y: number) {
    let op = binop into BinOp ?? add
    return op(x, y)
}

fn sub(x: number, y: number) { return x - y }
fn mul(x: number, y: number) { return x * y }
fn div(x: number, y: number) { return x / y }

print(does_binop_or_fail(div, 10, 10))
print(does_binop_or_fail(null, 10, 10))
print(does_binop_or_fail(mul, 10, 10))

return BinOp
*/

fn norm2(re: number, im: number) {
    return re * re - im * (-im)
}

fn abs(re: number, im: number) {
    return sqrt(norm2(re, im))
}

fn level(x: number, y: number) {
    let cre = x
    let cim = y
    let zre = cre
    let zim = cim

    for l in 255 {
        let tre = zre * zre - zim * zim
        let tim = zre * zim + zim * zre

        zre = tre + cre
        zim = tim + cim

        if abs(zre, zim) > 2 {
            return l
        }
    }

    return 255
}

for outer in 15 {
    let start = time()

    let xmin = -2
    let xmax = 2
    let ymin = -2
    let ymax = 2
    let n = 256

    let dx = 4 / n
    let dy = 4 / n

    let result = 0
    for i in n {
        let x = xmin + i * dx
        for j in n {
            let y = ymin + j * dy
            result += level(x, y)
        }
    }

    let duration_ms = time() - start
    print("Finished in", duration_ms / 1000, "ms", "|", result)
}


for outer in 15 {
    let start_time = time()
    
    let total: number = 0
    let inner = 10
    for i in 10000000 {
        total += inner
    }
    
    let end_time = time()
    
    let duration_ms = end_time - start_time
    print("10m typed iterations took", duration_ms / 1000, "ms", "|", total)
}

fn add_slow(x, y) { return x + y }

for outer in 15 {
    let start_time = time()
    
    let total: any = 0
    let inner: any = 10
    for i in 10000000 {
        total += inner
    }
    
    let end_time = time()
    
    let duration_ms = end_time - start_time
    print("10m untyped iterations took", duration_ms / 1000, "ms", "|", total)
}