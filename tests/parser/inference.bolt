import * from "../test"

push_scope("inference")

test("basic type inference", fn {
    let a = 10
    let b = "string"
    let c = false
    let d = null

    expect(typeof(a) == number,     "Expected a to be 'number'")
    expect(typeof(b) == string,     "Expected b to be 'string'")
    expect(typeof(c) == bool,       "Expected c to be 'bool'")
    expect(typeof(d) == type(null), "Expected d to be 'null'")

    expect(a is number,     "Expected a to be 'number'")
    expect(b is string,     "Expected b to be 'string'")
    expect(c is bool,       "Expected c to be 'bool'")
    expect(d is type(null), "Expected d to be 'null'")
})

test("array type inference", fn {
    let a = []
    let b = [1, 2, 3]
    let c = ["a", "b", "c"]

    expect(typeof(a) == type([any]),    "Expected a to be '[any]'")
    expect(typeof(b) == type([number]), "Expected b to be '[number]'")
    expect(typeof(c) == type([string]), "Expected c to be '[string]'")

    expect(a is type([any]),    "Expected a to be '[any]'")
    expect(b is type([number]), "Expected b to be '[number]'")
    expect(c is type([string]), "Expected c to be '[string]'")
})

test("union type array inference", fn {
    let a = [1, "string", true]
    let b = [1, null, 2, 3]
    let c = [string, number, 10]

    expect(typeof(a) == type([number | string | bool]), "Expected a to be '[number | string | bool]'")
    expect(typeof(b) == type([number?]),                "Expected b to be '[number?]'")
    expect(typeof(c) == type([Type | number]),          "Expected c to be '[Type | number]'")

    expect(a is type([number | string | bool]), "Expected a to be '[number | string | bool]'")
    expect(b is type([number?]),                "Expected b to be '[number?]'")
    expect(c is type([Type | number]),          "Expected c to be '[Type | number]'")
})

test("tableshape type inference", fn {
    let a = { a: 100 }

    expect(typeof(a) == type({ a: number }), "Expected a to be '{a: number}'")
    expect(a is type({ a: number }), "Expected a to be '{a: number}'")
})

test("nested tableshape type inference", fn {
    let a = {
        a: { a: [1, 2, 3] }
    }

    expect(typeof(a) == type({a: {a: [number]}}), "Expected a to be '{a: {a: [number]}}'")
    expect(a is type({a: {a: [number]}}), "Expected a to be '{a: {a: [number]}}'")
})

test("function return inference", fn {
    fn f { return 10 }

    expect(typeof(f()) == number, "Expceted f() to be 'number'")
    expect(f() is number, "Expceted f() to be 'number'")
})

test("branched function return inference", fn {
    fn f {
        if true { return false }
        else { return true }
    
        return false // branch checking is not exhaustive yet 
    }

    expect(typeof(f()) == bool, "Expceted f() to be 'bool'")
    expect(f() is bool, "Expceted f() to be 'bool'")
})

test("union branched function return inference", fn {
    fn f {
        if true { return 10 }
        return false // branch checking is not exhaustive yet 
    }

    expect(typeof(f()) == type(number | bool), "Expceted f() to be 'number | bool'")
    expect(f() is type(number | bool), "Expceted f() to be 'number | bool'")
})

test("empty function signature inference", fn {
    fn f {}

    expect(typeof(f) == type(fn), "Expected f to be 'fn'")
    expect(f is type(fn), "Expected f to be 'fn'")
})

test("parameterless function signature inference", fn {
    fn f: number { return 10 }

    expect(typeof(f) == type(fn: number), "Expected f to be 'fn: number'")
    expect(f is type(fn: number), "Expected f to be 'fn: number'")
})

test("one-parameter returnless function signature inference", fn {
    fn f(x: number) { let y = x }

    expect(typeof(f) == type(fn(number)), "Expected f to be 'fn(number)'")
    expect(f is type(fn(number)), "Expected f to be 'fn(number)'")
})

test("one-parameter function signature inference", fn {
    fn f(x: number): number { return x }

    expect(typeof(f) == type(fn(number): number), "Expected f to be 'fn(number): number'")
    expect(f is type(fn(number): number), "Expected f to be 'fn(number): number'")
})

test("many-parameter function signature inference", fn {
    fn f(x: number, y: string, z: bool): number { return x }

    expect(typeof(f) == type(fn(number, string, bool): number), "Expected f to be 'fn(number, string, bool): number'")
    expect(f is type(fn(number, string, bool): number), "Expected f to be 'fn(number, string, bool): number'")
})

test("many-parameter function expression inference", fn {
    let const f = fn(x: number, y: string, z: bool) { return x }

    expect(typeof(f) == type(fn(number, string, bool): number), "Expected f to be 'fn(number, string, bool): number'")
    expect(f is type(fn(number, string, bool): number), "Expected f to be 'fn(number, string, bool): number'")
})

test("function with ifs signature inference", fn {
    fn f(x: any, t: string) {
        if t == "string" {
            return x as string!
        } else if t == "number" {
            return x as number!
        }

        return null
    }

    expect(typeof(f) == type(fn(any, string): string | number | null), "Expected f to be 'fn(any, string): string | number | null'")
    expect(f is type(fn(any, string): string | number | null), "Expected f to be 'fn(any, string): string | number | null'")
})

test("function with ifs returning unions signature inference", fn {
    fn f(x: any, t: string) {
        if t == "string" {
            return x as string
        } else if t == "number" {
            return x as number
        }

        return null
    }

    expect(typeof(f) == type(fn(any, string): string | number | null), "Expected f to be 'fn(any, string): string | number | null'")
    expect(f is type(fn(any, string): string | number | null), "Expected f to be 'fn(any, string): string | number | null'")
})

test("function with nested ifs returning unions signature inference", fn {
    fn f(x: any, t: string) {
        if t == "string" {
            if t == "true" {
                return true
            } else if t == "false" {
                return false
            } else {
                return x as string
            }
        } else if t == "number" {
            return x as number
        }

        return null
    }

    expect(typeof(f) == type(fn(any, string): string | number | bool | null), "Expected f to be 'fn(any, string): string | number | bool | null'")
    expect(f is type(fn(any, string): string | number | bool | null), "Expected f to be 'fn(any, string): string | number | bool | null'")
})

test("function with infinite loop signature inference", fn {
    fn f() {
        for { return 1 }
        return false
    }

    expect(typeof(f) == type(fn: number | bool), "Expected f to be 'fn: number | bool'")
    expect(f is type(fn: number | bool), "Expected f to be 'fn: number | bool'")
})

test("if-expr correctly infers type", fn {
    let const x = if true then 10 else 20

    expect(typeof(x) == number, "Expected x to be 'number'")
    expect(x is number, "Expected x to be 'number'")
})

test("if-expr correctly infers type with else if branches", fn {
    let const x = if true then 10 
                else if false then 20
                else 30

    expect(typeof(x) == number, "Expected x to be 'number'")
    expect(x is number, "Expected x to be 'number'")
})

test("if-expr correctly infers union type", fn {
    let const x = if true then 10 else "badabing!"

    expect(typeof(x) == type(number | string), "Expected x to be 'number | string'")
    expect(x is type(number | string), "Expected x to be 'number | string'")
})

test("if-expr correctly infers union type with else if branches", fn {
    let const x = if true then 10 
                else if false then null
                else "badabing!"

    expect(typeof(x) == type(number | string | null), "Expected x to be 'number | string | null'")
    expect(x is type(number | string | null), "Expected x to be 'number | string | null'")
})

test("if-expr correctly infers type without else clause", fn {
    let const x = if true then 10

    expect(typeof(x) == type(number?), "Expected x to be 'number?'")
    expect(x is type(number?), "Expected x to be 'number?'")
})

test("if-expr correctly infers type without expression", fn {
    let const x = if true {}

    expect(typeof(x) == type(null), "Expected x to be 'null'")
    expect(x is type(null), "Expected x to be 'null'")
})

test("for-expr correctly infers type", fn {
    let const x = for i in 10 do i

    expect(typeof(x) == type([number]), "Expected x to be `[number]`")
    expect(x is type([number]), "Expected x to be `[number]`")
})

test("for-expr correctly infers union type", fn {
    let const x = for i in 10 do if true then "hello!" else false

    expect(typeof(x) == type([string | bool]), "Expected x to be `[string | bool]`")
    expect(x is type([string | bool]), "Expected x to be `[string | bool]`")
})

test("for-expr correctly infers type with no expression", fn {
    let const x = for i in 10 {}

    expect(typeof(x) == type([null]), "Expected x to be `[null]`")
    expect(x is type([null]), "Expected x to be `[null]`")
})

pop_scope()