import * from "../../test"

push_scope("arrays")

test("empty array type inference", fn {
    let a = []

    expect(typeof(a) == type([any]), "Expected a to be '[any]'")
})

test("primitive array type inference", fn {
    let b = [1, 2, 3]

    expect(typeof(b) == type([number]), "Expected b to be '[number]'")
})

test("object array type inference", fn {
    type T = { a: number }
    let b = [{a: 1}, {a: 2}, {a: 3}]

    expect(typeof(b) == type([T]), "Expected b to be '[T]'")
})

test("prototype object array type inference", fn {
    type T = { a: number }
    fn T.a {}

    let b = [T => {a: 1}, T => {a: 2}, T => {a: 3}]

    expect(typeof(b) == type([T]), "Expected b to be '[T]'")
})

test("union type array inference", fn {
    let a = [1, "string", true]
    let b = [1, null, 2, 3]
    let c = [string, number, 10]

    expect(typeof(a) == type([number | string | bool]), "Expected a to be '[number | string | bool]'")
    expect(typeof(b) == type([number?]),                "Expected b to be '[number?]'")
    expect(typeof(c) == type([Type | number]),          "Expected c to be '[Type | number]'")
})

test("strongly typed array literal inference", fn {
    let a = [:number]
    let b = [:string]
    let c = [:null]

    expect(typeof(a) == type([number]), "Expected a to be '[number]'")
    expect(typeof(b) == type([string]), "Expected b to be '[string]'")
    expect(typeof(c) == type([null]),   "Expected c to be '[null]'")
})

test("complex typed array literal inference", fn {
    let a = [:number | string]
    let b = [:string?]
    let c = [:{a: number}]

    expect(typeof(a) == type([number | string]), "Expected a to be '[number | string]'")
    expect(typeof(b) == type([string?]),         "Expected b to be '[string?]'")
    expect(typeof(c) == type([{a: number}]),     "Expected c to be '[{a: number}]'")
})

test("typed empty array literal", fn {
    let a: [number] = []

    expect(typeof(a) == type([number]), "Expected 'a' to be '[number]'")
})

test("typed empty array literal as argument", fn {
    fn len(arr: [number]) { return arr.length() }

    expect(len([]) == 0, "Expected length of '[]' to be '0'")
})

test("typed empty array literal as table value", fn {
    let t = {
        x: []
    }

    expect(typeof(t.x) == type([any]), "Expected 't.x' to be '[any]'")
})

test("typed empty array literal as tableshape value", fn {
    type T = { arr: [number] }

    let t = T => { arr: [] }

    expect(typeof(t.arr) == type([number]), "Expected 't.arr' to be '[number]'")
})

pop_scope()