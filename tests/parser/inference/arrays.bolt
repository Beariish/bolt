import * from "../../test"

push_scope("arrays")

test("empty array type inference", fn {
    let a = []

    expect(typeof(a) == type([any]), "Expected a to be '[any]'")
    expect(a is type([any]),         "Expected a to be '[any]'")
})

test("primitive array type inference", fn {
    let b = [1, 2, 3]

    expect(typeof(b) == type([number]), "Expected b to be '[number]'")
    expect(b is type([number]),         "Expected b to be '[number]'")
})

test("object array type inference", fn {
    type T = { a: number }
    let b = [{a: 1}, {a: 2}, {a: 3}]

    expect(typeof(b) == type([T]), "Expected b to be '[T]'")
    expect(b is type([T]),         "Expected b to be '[T]'")
})

test("prototype object array type inference", fn {
    type T = { a: number }
    fn T.a {}

    let b = [T => {a: 1}, T => {a: 2}, T => {a: 3}]

    expect(typeof(b) == type([T]), "Expected b to be '[T]'")
    expect(b is type([T]),         "Expected b to be '[T]'")
})

test("union type array inference", fn {
    let a = [1, "string", true]
    let b = [1, null, 2, 3]
    let c = [string, number, 10]

    expect(typeof(a) == type([number | string | bool]), "Expected a to be '[number | string | bool]'")
    expect(typeof(b) == type([number?]),                "Expected b to be '[number?]'")
    expect(typeof(c) == type([Type | number]),          "Expected c to be '[Type | number]'")

    expect(a is type([number | string | bool]), "Expected a to be '[number | string | bool]'")
    expect(b is type([number?]),                "Expected b to be '[number?]'")
    expect(c is type([Type | number]),          "Expected c to be '[Type | number]'")
})

test("strongly typed array literal inference", fn {
    let a = [:number]
    let b = [:string]
    let c = [:null]

    expect(typeof(a) == type([number]), "Expected a to be '[number]'")
    expect(typeof(b) == type([string]), "Expected b to be '[string]'")
    expect(typeof(c) == type([null]),   "Expected c to be '[null]'")

    expect(a is type([number]), "Expected a to be '[number]'")
    expect(b is type([string]), "Expected b to be '[string]'")
    expect(c is type([null]),   "Expected c to be '[null]'")
})

test("complex typed array literal inference", fn {
    let a = [:number | string]
    let b = [:string?]
    let c = [:{a: number}]

    expect(typeof(a) == type([number | string]), "Expected a to be '[number | string]'")
    expect(typeof(b) == type([string?]),         "Expected b to be '[string?]'")
    expect(typeof(c) == type([{a: number}]),     "Expected c to be '[{a: number}]'")

    expect(a is type([number | string]), "Expected a to be '[number | string]'")
    expect(b is type([string?]),         "Expected b to be '[string?]'")
    expect(c is type([{a: number}]),     "Expected c to be '[{a: number}]'")
})

pop_scope()