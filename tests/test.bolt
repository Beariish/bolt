import * from core

type TestCase = {
    scope_name: string,
    name: string,
    result: bool,
    failures: [string],
    body: fn
}

type TestScope = {
    name: string,
    tests: [TestCase],
    subscopes: [TestScope],
    parent: TestScope?
}

type TestState = {
    root: TestScope,
    current_scope: TestScope?,
    current_test: TestCase?,
    failures: [TestCase],
    total_tests: number,
}

let state = TestState => {
    root: TestScope => {
        name: "",
        tests: [:TestCase],
        subscopes: [:TestScope],
        parent: null,
    },
    current_scope: null,
    current_test: null,
    failures: [:TestCase],
    total_tests: 0
}

state.current_scope = state.root

fn run_scope(scope: TestScope): ! {
    let n_total = scope.tests.length()
    let n_success = 0

    for test in scope.tests.each() {
        state.current_test = test
        state.total_tests += 1

        if let e = protect(test.body) as Error {
            test.failures.push(e.what)
            state.failures.push(test)
        }
        else if test.result {
            n_success += 1
        } else {
            state.failures.push(test)
        }
    }

    if n_total > 0 {
        print("[" + scope.name + "] " + to_string(n_success) + "/" + to_string(n_total) + " tests successful!")
    }

    for subscope in scope.subscopes.each() {
        run_scope(subscope)
    }
}

fn run {
    run_scope(state.root)

    if state.failures.length() > 0 {
        print("Tests Failed (" + to_string(state.failures.length()) + "):")
        for test in state.failures.each() {
            print("[" + test.scope_name + "]: " + test.name)
            for message in test.failures.each() {
                print("-    " + message)
            }
        }
    }

    let const n_passed = state.total_tests - state.failures.length()
    print("DONE: " + to_string(n_passed) + "/" + to_string(state.total_tests) + " tests passed!")
}

fn push_scope(name: string) {
    let new_name = state.current_scope!.name

    if new_name.length() > 0 { new_name += "." }
    new_name += name

    let const new_scope = TestScope => {
        name: new_name,
        tests: [:TestCase],
        subscopes: [:TestScope],
        parent: state.current_scope
    }
    
    state.current_scope!.subscopes.push(new_scope)
    state.current_scope = new_scope
} 

fn pop_scope {
    state.current_scope = state.current_scope!.parent

    if state.current_scope == state.root {
        run()
    }
}

fn test(name: string, body: fn) {
    let scope = state.current_scope!
    scope.tests.push(
        TestCase => {
            scope_name: scope.name,
            name: name,
            result: true,
            failures: [:string],
            body: body
        }
    )
}

fn expect(condition: bool, message: string) {
    if not condition {
        if let test = state.current_test {
            test.result = false
            test.failures.push(message)
        } else {
            print("TRIED TO RAISE ERROR WITH NO CURRENT TEST SET!!")
        }
    }
}

export push_scope
export pop_scope
export test
export expect
