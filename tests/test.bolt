import * from core

type TestCase = {
    name: string,
    result: bool,
    failures: [string],
    body: fn
}

let all_tests: [TestCase]

fn case(name: string, body: fn) {
    all_tests.push(TestCase => {
        name: name,
        result: true,
        failures: [:string],
        body: body
    })
}

fn prefix(pfx: string) { 
    return fn(name: string, body: fn) {
        case(pfx + ": " + name, body)
    } 
}

let current_test: { inner: TestCase? }

fn expect(condition: bool, message: string) {
    if not condition {
        if let test = current_test.inner {
            test.result = false
            test.failures.push(message)
        } else {
            print("TRIED TO RAISE ERROR WITH NO CURRENT TEST SET!!")
        }
    }
}

fn run {
    print("Running", all_tests.length(), "tests...")
    
    let start_time = time()

    let failures = [:TestCase]
    for test in all_tests.each() {
        current_test.inner = test

        let result = protect(test.body)
        
        if let error = result as Error {
            expect(false, "Test failed with runtime error: " + to_string(error.what))
        }

        if not test.result {
            failures.push(test)
        }
    }

    let end_time = time()

    print("Run complete in", to_string((end_time - start_time) / 1000) + "ms!")
    print("[" + to_string(all_tests.length() - failures.length()) + "/" + to_string(all_tests.length()) + "] tests succeeded!")

    if failures.length() > 0 {
        print("Failures:")
    }

    for const test in failures.each() {
        print("-", test.name)
        for const reason in test.failures.each() {
            print("   \"" + reason + "\"")
        }
    }
}

export case
export prefix
export expect
export run