import * from core
import * from math
import * from "bench"

bench("populating 1m array", 15, fn {
    let result: [number]
    for i in 1000000 { result.push(i) }
})

bench_with_pre_work("popping from 1m array", 15, fn {
    let result: [number]
    for i in 1000000 { result.push(i) }

    return fn {
        for i in result.length() { result.pop() }
    }
})

let to_probe: [number]
for i in 1000000 { to_probe.push(i) }

bench("1m array.length() invocations", 20, fn {
    for i in 1000000 { to_probe.length() }
})

bench("1m array index", 50, fn {
    for i in to_probe.length() { 
        let item = to_probe[i]
    }
})

bench("1m untyped array index", 50, fn {
    let idx = 1 as any!
    for i in to_probe.length() { 
        let item = to_probe[idx]
    }
})

bench("1m array assignment", 50, fn {
    let arr = [1, 2, 3]
    for i in 1000000 {
        arr[1] = i
    }
})

bench("1m untyped array assignment", 50, fn {
    let idx = 1 as any!
    let arr = [1, 2, 3]
    for i in 1000000 {
        arr[idx] = i
    }
})

fn doubler(x: number) { return x * 2 }

bench("mapping 1m array", 20, fn {
    let new_arr = to_probe.map(doubler)
})

bench("manual mapping 1m array", 20, fn {
    let res = [:number]
    for const n in to_probe.each() { res.push(n * 2) }
})

bench("clone and map 1m array", 20, fn {
    let new_arr = to_probe.clone()
    for i in new_arr.length() {
        new_arr[i] = new_arr[i] * 2
    }
})

bench("reverse 1m array", 100, fn { to_probe.reverse() })

bench("filter 1m array", 20, fn {
    let evens = to_probe.filter(fn(n: number) { return imod(n, 2) == 0 })
})

bench("small slice 1m array", 20, fn {
    let slice = to_probe.slice(1000, 100)
})

bench("large slice 1m array", 20, fn {
    let slice = to_probe.slice(1000, 100000)
})

bench_with_pre_work("builtin sort 1m array", 10, fn {
    to_probe.reverse()

    return fn {
        to_probe.sort(null)
    }
})

bench_with_pre_work("in-lang sort 1m array", 10, fn {
    to_probe.reverse()

    return fn {
        to_probe.sort(fn(a: number, b: number) { return a < b })
    }
})

bench("7-element complex op", 10000, fn {
    let arr = 
        [0, 3, 1, 4, 5, 2, 0]
            .slice(1, 5)
            .sort()
            .reverse()
            .map(fn(x: number) { return x * 2 })
})