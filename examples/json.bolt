import to_number, error, Error, print from core
import min from math

export type JsonValue = 
                 null 
               | number 
               | bool 
               | string 
               | [JsonValue] 
               | { ..string: JsonValue }

type ParseSuccess = {
    remainder: number,
    result: JsonValue
}

type ParseResult = ParseSuccess | Error

let const whitespace: { ..string: bool } = {
    " ": true, "\n": true, "\t": true, "\r": true
}

let const numchars: { ..string: bool } = {
    "0": true, "1": true, "2": true, "3": true, "4": true, "5": true, "6": true, "7": true, "8": true, "9": true, ".": true,
}

fn json_parse_word(content: string, idx: number, word: string) {
    return if content.compare_at(word, idx) 
            then idx + word.length()
            else null
}

fn json_parse_null (content: string, idx: number) { return json_parse_word(content, idx, "null")  }
fn json_parse_true (content: string, idx: number) { return json_parse_word(content, idx, "true")  }
fn json_parse_false(content: string, idx: number) { return json_parse_word(content, idx, "false") }

fn eat_whitespace(s: string, idx: number) {
    let first_idx = idx - 1
    let first = " "

    for whitespace[first]? {
        first_idx += 1
        if s.length() < first_idx + 1 { return 0 }
        first = s.substring(first_idx, 1)
    }

    return first_idx
}

fn json_parse_string(content: string, idx: number): ParseResult {
    let first = content.substring(idx, 1)
    if first != "\"" { return error("Expected string to start with quote") }
    
    let result = ""
    let length = 0
    let last_eaten = 1
    first = ""
    for first != "\"" {
        length += 1
        if content.length() < length + idx { return error("Unexpected end of source") }
        first = content.substring(idx + length, 1)

        if first == "\"" { break }

        if first == "\\" {
            result += content.substring(idx + last_eaten, length - last_eaten)
            last_eaten = length + 2

            first = content.substring(idx + length + 1, 1)

            match first {
                "n" { result += "\n" }
                "t" { result += "\t" }
                "r" { result += "\r" }
                else { result += first }
            }

            length += 1
            first = content.substring(length + 1, 1)
        }
    }

    result += content.substring(idx + last_eaten, length - last_eaten)

    return ParseSuccess => {
        remainder: idx + length + 1,
        result: result
    }
}

fn parse_single(content: string, idx: number): ParseResult {
    idx = eat_whitespace(content, idx)
    
    match let first = content.substring(idx, 1) {
        "n" {
            return if let remainder = json_parse_null(content, idx)
                then ParseSuccess => { remainder: remainder, result: null }
                else error("Expected null, got " + content.substring(idx, min(content.length(), 4)))
        }
        
        "t" {
            return if let remainder = json_parse_true(content, idx)
                then ParseSuccess => { remainder: remainder, result: true }
                else error("Expected true, got " + content.substring(idx, min(content.length(), 4)))
        }
        "f" {
            return if let remainder = json_parse_false(content, idx)
                then ParseSuccess => { remainder: remainder, result: false }
                else error("Expected false, got " + content.substring(idx, min(content.length(), 5)))
        } 
        (numchars[first]?) {
            let last_idx = idx + 1
            let last = content.substring(last_idx, 1)

            for numchars[last]? and content.length() > last_idx + 1 {
                last_idx += 1
                last = content.substring(last_idx, 1)
            }

            let num_str = content.substring(idx, last_idx - idx)
            return if let num = to_number(num_str) 
                then ParseSuccess => { remainder: last_idx, result: num }
                else error("Expected number")
        }
        "\"" {
            return json_parse_string(content, idx)
        }
        "[" {
            let result = [:JsonValue]
            for first != "]" {
                idx += 1
                idx = eat_whitespace(content, idx)

                match let value = parse_single(content, idx) {
                    is Error { return value }
                    is ParseSuccess {
                        result.push(value.result)
                        idx = value.remainder
                    }
                }

                idx = eat_whitespace(content, idx)
                if content.length() < idx { return error("Unexpected end of file in array") }
                first = content.substring(idx, 1)

                if first == "," {
                    idx += 1
                    if content.length() < idx { return error("Unexpected end of file in array") }
                    first = content.substring(idx, 1)
                }
            }

            return ParseSuccess => {
                remainder: idx + 1,
                result: result
            }
        } 
        "{" {
            idx += 1

            let result: { ..string: JsonValue } = {}
            for first != "}" {
                idx = eat_whitespace(content, idx)

                first = content.substring(idx, 1)
                if first == "," {
                    idx = eat_whitespace(content, idx + 1)
                }

                if content.length() < idx { return error("Unexpected end of source") }
                
                match let key = json_parse_string(content, idx) {
                    is Error { return key }
                    is ParseSuccess {
                        idx = eat_whitespace(content, key.remainder)
                        if content.length() < idx { return error("Unexpected end of source") }
                        if content.substring(idx, 1) != ":" { return error("Expected colon") }
                        idx = eat_whitespace(content, idx + 1)

                        match let value = parse_single(content, idx) {
                            is Error { return value },
                            is ParseSuccess {
                                result[key.result as string!] = value.result
                                idx = eat_whitespace(content, value.remainder)
                                if content.length() < idx { return error("Unexpected end of source") }
                                first = content.substring(idx, 1)
                            }
                        }
                    }
                }
            }

            return ParseSuccess => {
                remainder: idx + 1,
                result: result
            }
        }
    }

    return error("Didn't match any object")
}

export fn parse(input: string): JsonValue | Error {
    return match let result = parse_single(input, 0) {
        is Error then result,
        is ParseSuccess then result.result,
    }!
}

import "clitools" as cli

if let args = cli.as_cli_module("json") {
    if args.length() < 2 {
        print("Usage: examples/json.bolt <file>")
    } else {
        let filename = args[1]
        match let file = cli.read_file(filename) {
            is string {
                match let json = parse(file) {
                    is JsonValue {
                        print("Parsed successfully!")
                        print("Content:")
                        print(json)
                    }

                    is Error {
                        print("Parsing failed:", json.what)
                    }
                }
            }

            is Error {
                print("Couldn't read file:", file.what)
            }
        }
    }
}