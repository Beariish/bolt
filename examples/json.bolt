import to_number, error, Error, print from core
import min from math

export type JsonValue = null 
               | number 
               | bool 
               | string 
               | [JsonValue] 
               | { ..string: JsonValue }

fn json_parse_null(content: string, idx: number) {
    if content.length() < idx + 4 { return null }

    let start = content.substring(idx, 4)

    if start == "null" {
        return idx + 4
    }

    return null
}

fn json_parse_true(content: string, idx: number) {
    if content.length() < idx + 4 { return null }

    let start = content.substring(idx, 4)

    if start == "true" {
        return idx + 4
    }

    return null
}

fn json_parse_false(content: string, idx: number) {
    if content.length() < idx + 5 { return null }

    let start = content.substring(idx, 5)

    if start == "false" {
        return idx + 5
    }

    return null
}

type ParseSuccess = {
    remainder: number,
    result: JsonValue
}

type ParseResult = ParseSuccess | Error

let whitespace: { ..string: bool } = {
    " ": true, "\n": true, "\t": true, "\r": true
}

let numchars: { ..string: bool } = {
    "0": true, "1": true, "2": true, "3": true, "4": true, "5": true, "6": true, "7": true, "8": true, "9": true, ".": true,
}

fn eat_whitespace(s: string, idx: number) {
    let first_idx = idx - 1
    let first = " "

    for whitespace[first]? {
        first_idx += 1
        if s.length() < first_idx + 1 { return "" }
        first = s.substring(first_idx, 1)
    }

    return first_idx
}

fn json_parse_string(content: string, idx: number): ParseResult {
    let first = content.substring(idx, 1)
    if first != "\"" { return error("Expected string to start with quote") }
    
    let result = ""
    let length = 0
    let last_eaten = 1
    first = ""
    for first != "\"" {
        length += 1
        if content.length() < length + idx { return error("Unexpected end of source") }
        first = content.substring(idx + length, 1)

        if first == "\"" { break }

        if first == "\\" {
            result += content.substring(idx + last_eaten, length - last_eaten)
            last_eaten = length + 2

            first = content.substring(idx + length + 1, 1)
            if first == "n" { result += "\n" }
            else if first == "t" { result += "\t" }
            else if first == "r" { result += "\r" }
            else { result += first }

            length += 1
            first = content.substring(length + 1, 1)
        }
    }

    result += content.substring(idx + last_eaten, length - last_eaten)

    return ParseSuccess => {
        remainder: idx + length + 1,
        result: result
    }
}

type JsonParser = final {}
method JsonParser.parse_single(content: string, idx: number): ParseResult {
    idx = eat_whitespace(content, idx)
    let first = content.substring(idx, 1)

    if first == "n" {
        if let remainder = json_parse_null(content, idx) {
            return ParseSuccess => {
                remainder: remainder,
                result: null
            }
        } else {
            return error("Expected null, got " + content.substring(idx, min(content.length(), 4)))
        }
    } else if first == "t" {
        if let remainder = json_parse_true(content, idx) {
            return ParseSuccess => {
                remainder: remainder,
                result: true
            }
        } else {
            return error("Expected true, got " + content.substring(idx, min(content.length(), 4)))
        }
    } else if first == "f" {
        if let remainder = json_parse_false(content, idx) {
            return ParseSuccess => {
                remainder: remainder,
                result: false
            }
        } else {
            return error("Expected false, got " + content.substring(idx, min(content.length(), 5)))
        }
    } else if numchars[first]? {
        let last_idx = idx + 1
        let last = content.substring(last_idx, 1)

        for numchars[last]? and content.length() > last_idx + 1 {
            last_idx += 1
            last = content.substring(last_idx, 1)
        }

        let num_str = content.substring(idx, last_idx - idx)
        if let num = to_number(num_str) {
            return ParseSuccess => {
                remainder: last_idx,
                result: num
            }
        } else {
            return error("Expected number")
        }
    } else if first == "\"" {
        return json_parse_string(content, idx)
    } else if first == "[" {
        let result = [:JsonValue]
        for first != "]" {
            idx += 1
            idx = eat_whitespace(content, idx)
            let value = this.parse_single(content, idx)

            if value is Error { return value }
            else if let res = value as ParseSuccess {
                result.push(res.result)
                idx = res.remainder
            }

            idx = eat_whitespace(content, idx)
            if content.length() < idx { return error("Unexpected end of file in array") }
            first = content.substring(idx, 1)

            if first == "," {
                idx += 1
                if content.length() < idx { return error("Unexpected end of file in array") }
                first = content.substring(idx, 1)
            }
        }

        return ParseSuccess => {
            remainder: idx + 1,
            result: result
        }
    } else if first == "{" {
        idx += 1

        let result: { ..string: JsonValue } = {}
        for first != "}" {
            idx = eat_whitespace(content, idx)

            first = content.substring(idx, 1)
            if first == "," {
                idx = eat_whitespace(content, idx + 1)
            }

            if content.length() < idx { return error("Unexpected end of source") }
            
            let key = json_parse_string(content, idx)
            if key is Error { return key }
            else if let s = key as ParseSuccess {
                idx = eat_whitespace(content, s.remainder)
                if content.length() < idx { return error("Unexpected end of source") }
                if content.substring(idx, 1) != ":" { return error("Expected colon") }
                idx = eat_whitespace(content, idx + 1)

                let value = this.parse_single(content, idx)
                if value is Error { return value }
                else if let v = value as ParseSuccess {
                    result[s.result as string!] = v.result
                    idx = eat_whitespace(content, v.remainder)
                    if content.length() < idx { return error("Unexpected end of source") }
                    first = content.substring(idx, 1)
                }
            }
        }

        return ParseSuccess => {
            remainder: idx + 1,
            result: result
        }
    }

    return error("Didn't match any object")
}

export fn parse(input: string): JsonValue | Error {
    let parser = JsonParser => {}
    let result = parser.parse_single(input, 0)
    
    if result is Error { return result as Error! }
    
    return (result as ParseSuccess!).result
}