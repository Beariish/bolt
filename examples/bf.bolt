import strings as s
import write, error, Error from core

fn do_loop(program: string, pc: number, start: string, end: string, dir: number): number {
    let nested = 0
    let search_pc = pc + dir
    for search_pc < program.length() {
        match let sp = program.substring(search_pc, 1) {
            start { nested += 1 }
            end {
                if nested == 0 {
                    return search_pc
                } else {
                    nested -= 1
                }
            }
        }

        search_pc += dir
    }

    return 0
}

export fn interpret(program: string, input: string) {
    // Standard bf cells
    let cells = for i in 30000 do 0
    let cell_idx = 0

    let input_idx = 0

    let pc = 0
    for pc < program.length() {
        match let p = program.substring(pc, 1) {
            "." { write(s.from_byte(cells[cell_idx])) }
            "," {
                let in_byte = if input_idx >= input.length()
                    then -1
                    else input.byte_at(input_idx)
                
                input_idx += 1
                cells[cell_idx] = in_byte
            }
            "+" { cells[cell_idx] += 1 }
            "-" { cells[cell_idx] -= 1 }
            "<" {
                cell_idx -= 1
                if cell_idx < 0 {
                    return error("Cell index out of bounds!")
                }
            }
            ">" {
                cell_idx += 1
                if cell_idx >= cells.length() {
                    return error("Cell index out of bounds!")
                }
            }
            "[" {
                if cells[cell_idx] == 0 {
                    pc = do_loop(program, pc, "[", "]", 1)
                }
            }
            "]" {
                if cells[cell_idx] != 0 {
                    pc = do_loop(program, pc, "]", "[", -1)
                }
            }
        }
        pc += 1
    }

    return null
}

export fn hello_world {
    // Stolen from https://en.wikipedia.org/wiki/Brainfuck
    match let result = interpret("
    [ This program prints \"Hello World!\" and a newline to the screen; its
    length is 106 active command characters. [It is not the shortest.]

    This loop is an \"initial comment loop\", a simple way of adding a comment
    to a BF program such that you don't have to worry about any command
    characters. Any \".\", \",\", \"+\", \"-\", \"<\" and \">\" characters are simply
    ignored, the \"[\" and \"]\" characters just have to be balanced. This
    loop and the commands it contains are ignored because the current cell
    defaults to a value of 0; the 0 value causes this loop to be skipped.
    ]
    ++++++++                Set Cell #0 to 8
    [
        >++++               Add 4 to Cell #1; this will always set Cell #1 to 4
        [                   as the cell will be cleared by the loop
            >++             Add 2 to Cell #2
            >+++            Add 3 to Cell #3
            >+++            Add 3 to Cell #4
            >+              Add 1 to Cell #5
            <<<<-           Decrement the loop counter in Cell #1
        ]                   Loop until Cell #1 is zero; number of iterations is 4
        >+                  Add 1 to Cell #2
        >+                  Add 1 to Cell #3
        >-                  Subtract 1 from Cell #4
        >>+                 Add 1 to Cell #6
        [<]                 Move back to the first zero cell you find; this will
                            be Cell #1 which was cleared by the previous loop
        <-                  Decrement the loop Counter in Cell #0
    ]                       Loop until Cell #0 is zero; number of iterations is 8

    The result of this is:
    Cell no :   0   1   2   3   4   5   6
    Contents:   0   0  72 104  88  32   8
    Pointer :   ^

    >>.                     Cell #2 has value 72 which is 'H'
    >---.                   Subtract 3 from Cell #3 to get 101 which is 'e'
    +++++++..+++.           Likewise for 'llo' from Cell #3
    >>.                     Cell #5 is 32 for the space
    <-.                     Subtract 1 from Cell #4 for 87 to give a 'W'
    <.                      Cell #3 was set to 'o' from the end of 'Hello'
    +++.------.--------.    Cell #3 for 'rl' and 'd'
    >>+.                    Add 1 to Cell #5 gives us an exclamation point
    >++.                    And finally a newline from Cell #6", "") {
        is Error { write("PROGRAM ERRORED! ", result.what) }
    }
}

export fn rot_13 {
    // Stolen from https://en.wikipedia.org/wiki/Brainfuck
    match let result = interpret("
    -,+[                         Read first character and start outer character reading loop
        -[                       Skip forward if character is 0
            >>++++[>++++++++<-]  Set up divisor (32) for division loop
                                (MEMORY LAYOUT: dividend copy remainder divisor quotient zero zero)
            <+<-[                Set up dividend (x minus 1) and enter division loop
                >+>+>-[>>>]      Increase copy and remainder / reduce divisor / Normal case: skip forward
                <[[>+<-]>>+>]    Special case: move remainder back to divisor and increase quotient
                <<<<<-           Decrement dividend
            ]                    End division loop
        ]>>>[-]+                 End skip loop; zero former divisor and reuse space for a flag
        >--[-[<->+++[-]]]<[         Zero that flag unless quotient was 2 or 3; zero quotient; check flag
            ++++++++++++<[       If flag then set up divisor (13) for second division loop
                                (MEMORY LAYOUT: zero copy dividend divisor remainder quotient zero zero)
                >-[>+>>]         Reduce divisor; Normal case: increase remainder
                >[+[<+>-]>+>>]   Special case: increase remainder / move it back to divisor / increase quotient
                <<<<<-           Decrease dividend
            ]                    End division loop
            >>[<+>-]             Add remainder back to divisor to get a useful 13
            >[                   Skip forward if quotient was 0
                -[               Decrement quotient and skip forward if quotient was 1
                    -<<[-]>>     Zero quotient and divisor if quotient was 2
                ]<<[<<->>-]>>    Zero divisor and subtract 13 from copy if quotient was 1
            ]<<[<<+>>-]          Zero divisor and add 13 to copy if quotient was 0
        ]                        End outer skip loop (jump to here if ((character minus 1)/32) was not 2 or 3)
        <[-]                     Clear remainder from first division if second division was skipped
        <.[-]                    Output ROT13ed character from copy and clear it
        <-,+                     Read next character
    ]                            End character reading loop", "This is my input!") {
        is Error { write("PROGRAM ERRORED! ", result.what) }
    }
}